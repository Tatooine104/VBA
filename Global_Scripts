' - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + -
' Скрипты общего назначения
' Шевченко Дмитрий <primalevil@gmail.com>
' - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + -
''' <summary>  </summary>
''' <param name="">  </param>
'Public Sub Script_Pattern()
'
'scGScreenUpdating Act:=False ' Выключаем обновление экрана
'
'ReDim Cols_Heads(1) As Variant: Cols_Heads = Array("") ' Имена столбцов с которыми будем взаимодействовать
'
'ReDim DataTable(1 To UBound(Cols_Heads) + 1) As Variant ' Создаем массив для данных с листа
'ReDim Calc_Cols(1) As Variant: Calc_Cols = Array("") ' Имена расчетных столбцов
'ReDim Cols_Form(1) As Variant: Cols_Form = Array("") ' Форматы расчетных столбцов при вставке
'
'Dim tSheet As Worksheet: Set tSheet = Лист2 ' Лист с которым будем взаимодействовать
'
'Call scGManipulateData(DataTable, tSheet, Cols_Heads, Calc_Cols, Cols_Form, True, True) ' Подхват данных с листа и отправка их в массив
'
'For ind& = LBound(DataTable(1)) + 1 To UBound(DataTable(1)) - 1 ' Перебор строк в массиве
'
'    DataTable(fnG_GetID(Cols_Heads, ""))(ind, 1) = ""
'
'Next ind
'
'Call scGManipulateData(DataTable, tSheet, Cols_Heads, Calc_Cols, Cols_Form, False, False) ' Вставка данных на лист
'
'Erase Cols_Heads, DataTable, Calc_Cols, Cols_Form
'
'scGScreenUpdating Act:=True ' Включаем обновление экрана
'
'End Sub
' - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + -
Public Sub scGManipulateData(ByRef DataTable As Variant, ByVal DataSheet As Worksheet, ByVal ColsNames As Variant, ByVal CalcCols As Variant, ByVal ColsFormats As Variant, ByVal PickUp As Boolean, ByVal ColsCheck As Boolean)
''' <summary> Скрипт подхвата данных с листа и вставки на лист этих данных обратно </summary>
''' <param name="DataTable"> Ссылка на массив данных с которым будем работать </param>
''' <param name="DataSheet"> Лист с которого будем брать / куда будем вставлять данные </param>
''' <param name="ColsNames"> Массив имен столбцов с которыми будем взяимодействовать </param>
''' <param name="CalcCols"> Массив имен расчетных столбцов </param>
''' <param name="ColsFormats"> Массив форматы расчетных столбцов </param>
''' <param name="PickUp"> Метка совершаемого действия. True - подхват данных с листа. False - Вставка данных на лист </param>
''' <param name="ColsCheck"> Метка необходимости проверки и очистки расчетных столбцов </param>

On Error GoTo scGManipulateData_Error ' При ошибке переход по метке

ReDim borders(1) As Long: borders = fnG_GetBorders(DataSheet, ColsNames(0)) ' Определяем первую и последнии строки в таблице

Dim checkcol As Boolean ' Логическое поле для метки проверять колонку перед работой с ней

For ind& = LBound(DataTable) To UBound(DataTable) ' Перебор столбцов
    
    checkcol = False ' Ставим метку что колонку проверять не нужно
    cformat$ = "-" ' Формат по умолчанию не меняем
    inf& = fnG_GetID(CalcCols, ColsNames(ind - 1)) - 1 ' Получаем индекс имени колонки в списке расчетных колонок
    If inf > -1 Then ' Сравниваем имя обрабатываемой колонки со списком расчетных колонок
        If ColsCheck Then checkcol = True ' Если стоит метка о необходимости проверки колокнки то ставим метку проверки колонки
        If Not PickUp Then cformat = ColsFormats(inf) ' Если это вставка данных, то указываем формат вставки данных
    End If
    If PickUp Then ' Проверяем какое действие нужно совершить
        DataTable(ind) = fnG_GetDataFromSheet(DataSheet, borders(0), borders(1), ColsNames(ind - 1), checkcol) ' Отправляем данные с листа в массив
    Else ' Если данные нужно вставить на лист
        Call scGSetDataOnSheet(DataSheet, borders(0), ColsNames(ind - 1), DataTable(ind), cformat, checkcol) ' Вставляем данные на лист
    End If

Next ind

If Not PickUp Then Call scGDeleteLastEmptyRow(DataSheet, ColsNames(0)) ' Стираем последнюю пустую строку которая появляется после вставки данных на лист

Erase borders

Exit Sub ' Завершение работы процедуры

scGManipulateData_Error: ' Что делать при ошибке

Call scG_ErrorLog(Err, "Global_Scripts", "scGManipulateData") ' Вызов обработчика ошибок

End Sub

' - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + -
Public Sub scG_StringToTXT(ByVal Text As String, ByVal filename As String)

On Error GoTo scG_StringToTXT_Error ' При ошибке переход по метке

Set FSO = CreateObject("scripting.filesystemobject")
check = Len(Dir(filename)) > 0
Set textfile = FSO.OpenTextFile(filename, 8, True)
textfile.Write vbNewLine & Text
textfile.Close
Set textfile = Nothing
Set FSO = Nothing

Exit Sub ' Завершение работы процедуры

scG_StringToTXT_Error: ' Что делать при ошибке

Call scG_ErrorLog(Err, "Global_Scripts", "scG_StringToTXT") ' Вызов обработчика ошибок

End Sub
' - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + -
Public Sub scG_ErrorLog(ByVal errn As Object, ByVal modulename As String, ByVal procname As String)

temp1$ = Now() & vbTab & ActiveWorkbook.Name & vbTab & Environ("COMPUTERNAME") & vbTab & Environ("USERNAME") & vbTab & modulename & vbTab & procname & vbTab & errn.Number & vbTab & Err.Description

temp2$ = ThisWorkbook.Path & "\Журнал ошибок " & Year(Now()) & "." & fnG_AddNulls(Month(Now), 2) & "." & fnG_AddNulls(Day(Now), 2) & ".txt"

Call scG_StringToTXT(temp1, temp2)

End Sub
' - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + -
''' <summary> Включение/Отключение обновление экрана </summary>
''' <param name="Act"> True/False - в зависимости от того нужно включить или выключить обновление экрана </param>
Public Sub scGScreenUpdating(ByVal Act As Boolean)

On Error GoTo scGScreenUpdating_Error ' При ошибке переход по метке

Application.ScreenUpdating = Act ' Выключаем обновление экрана
Application.EnableEvents = Act ' Отключаем события
Application.DisplayStatusBar = Act ' Отключаем статусбар
Application.DisplayAlerts = Act ' Отключаем предупреждения

Exit Sub ' Завершение работы процедуры

scGScreenUpdating_Error: ' Что делать при ошибке

Call scG_ErrorLog(Err, "Global_Scripts", "scGScreenUpdating") ' Вызов обработчика ошибок

End Sub
' - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + -
''' <summary> Удалить первую пустую строку в конце таблицы, которая неизбежно появляется после вставки данных на лист </summary>
''' <param name="tSheet"> Лист на котором будем удалять строку </param>
''' <param name="ColHead"> Колонка по которой будем определять границы таблицы. Колонка не должна содержать пустых строк </param>
Public Sub scGDeleteLastEmptyRow(ByVal tSheet As Worksheet, ByVal ColHead As String) ' Удаление последней пустой строки которая появляется после вставки данных на лист

On Error GoTo scGDeleteLastEmptyRow_Error ' При ошибке переход по метке

For i& = 1 To 1048576 ' Перебор строк на листе

    If Not tSheet.Range(i & ":" & i).Find(ColHead, , , xlWhole) Is Nothing Then Exit For ' При нахождении в строке исклмого заняения выходим из цикла
    
Next i

sCol& = tSheet.Range(i & ":" & i).Find(ColHead, , , xlWhole).Column ' Находим номер колонки с искомым значением
lRow& = tSheet.Range(tSheet.Cells(i, sCol), tSheet.Cells(1048576, sCol)).Find("").Row ' Находим в этой колонке пустую строку
Rows(lRow & ":" & lRow).Delete Shift:=xlUp ' удаляем строку

Exit Sub ' Завершение работы процедуры

scGDeleteLastEmptyRow_Error: ' Что делать при ошибке

Call scG_ErrorLog(Err, "Global_Scripts", "scGDeleteLastEmptyRow") ' Вызов обработчика ошибок

End Sub
' - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + -
''' <summary> Проверка колонки - Если существует, то очищаеися, если нет, то - создается </summary>
''' <param name="aSheet"> Лист с которым будем взаимодействовать </param>
''' <param name="bText"> Имя проверяемой колонки </param>
''' <param name="cRow"> Номер строки на которой находится шапка таблицы </param>
Public Sub scGCheck_Col(ByVal aSheet As Worksheet, ByVal bText As String, ByVal cRow As Long)

On Error GoTo scGCheck_Col_Error ' При ошибке переход по метке

If Not aSheet.Range(cRow & ":" & cRow).Find(bText, , , xlWhole) Is Nothing Then ' ищем в указанной строке нужное значение
    
    aSheet.Range(cRow & ":" & cRow).Find(bText, , , xlWhole).EntireColumn.ClearContents ' Если нашли колонку, то стираем все данные из нее
    aSheet.Cells(cRow, aSheet.Range(cRow & ":" & cRow).Find("", , , xlWhole).Column).Value = bText ' Заново вписываем на лист имя колонки
        
Else ' Если колонка не существует
    
    aSheet.Cells(cRow, aSheet.Range(cRow & ":" & cRow).Find("").Column).Value = bText ' Ищем в указанной строке пустую ячейку и вписываем им колонки
    
End If

Exit Sub ' Завершение работы процедуры

scGCheck_Col_Error: ' Что делать при ошибке

Call scG_ErrorLog(Err, "Global_Scripts", "scGCheck_Col") ' Вызов обработчика ошибок

End Sub
' - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + -
''' <summary> Удалить указанный файл </summary>
''' <param name="filename"> Имя файла который будем удалять </param>
Public Sub scGDeleteFile(ByVal filename As String)

On Error GoTo scGDeleteFile_Error ' При ошибке переход по метке

Kill filename ' Удаляем файл

Exit Sub ' Завершение работы процедуры

scGDeleteFile_Error: ' Что делать при ошибке

Call scG_ErrorLog(Err, "Global_Scripts", "scGDeleteFile") ' Вызов обработчика ошибок

End Sub
' - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + -
''' <summary> Переименовать указанный файл </summary>
''' <param name="filename"> Имя файла который будем переименовывать </param>
Public Sub scGRenameDoneFile(ByVal filename As String)

On Error GoTo scGRenameDoneFile_Error ' При ошибке переход по метке

newname = Left(filename, Len(filename) - InStr(StrReverse(filename), "\")) & "\" & Environ("USERNAME") & " " & Right(filename, InStr(StrReverse(filename), "\") - 1) ' Новое имя файла
Name filename As newname ' Переименовываем вставляя в начало имени файла - имя юзера обработавшего файл

Exit Sub ' Завершение работы процедуры

scGRenameDoneFile_Error: ' Что делать при ошибке

Call scG_ErrorLog(Err, "Global_Scripts", "scGRenameDoneFile") ' Вызов обработчика ошибок

End Sub
' - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + -
''' <summary> Вставить данные из массива на лист </summary>
''' <param name="nSheet"> Лист на который будем вставлять данные </param>
''' <param name="fRow"> Номер строки где "Шапка" таблицы </param>
''' <param name="ColName"> Имя колонки куда вставляем данные </param>
''' <param name="dTable"> Массив данных </param>
''' <param name="nFormat"> Формат ячеек куда будем вставлять данные </param>
''' <param name="checkcol"> Метка проверки колонки </param>
Public Sub scGSetDataOnSheet(ByVal nSheet As Worksheet, ByVal fRow As Long, ByVal ColName As String, ByVal dTable As Variant, ByVal nFormat As String, ByVal checkcol As Boolean)

On Error GoTo scGSetDataOnSheet_Error ' При ошибке переход по метке

If checkcol Then Call scGCheck_Col(nSheet, ColName, fRow) ' Проверяем колонку если метка = True

Dim cFor As Boolean
cFor = False

tCol& = nSheet.Range(fRow & ":" & fRow).Find(ColName, , , xlWhole).Column ' Ищем номер колонки куда будем вставлять данные

Select Case nFormat ' Проверяем формат вставляемых данных
        Case "Text" ' Текстовый формат
                cformat = "@"
                cFor = True
        Case "All" ' Общий формат
                cformat = "General"
                cFor = True
        Case "Number" ' Целые числа
                cformat = "0"
                cFor = True
        Case "0.00" ' Числа до сотых
                cformat = "0.00"
                cFor = True
        Case "Date" ' Дата
                cformat = "m/d/yyyy"
                cFor = True
        Case "Money" ' Финансовый
                cformat = "_($* #,##0.00_);_($* (#,##0.00);_($* ""-""??_);_(@_)"
                cFor = True
'        Case Else ' В любом другом случае - текстовый
'                cformat = "@"
End Select
    
If cFor Then nSheet.Range(nSheet.Cells(fRow, tCol), nSheet.Cells(fRow + UBound(dTable) - 1, tCol)).NumberFormat = cformat ' диапазон куда будем вставлять преобразуем в нужный формат
nSheet.Range(nSheet.Cells(fRow, tCol), nSheet.Cells(fRow + UBound(dTable) - 1, tCol)) = dTable ' вставляем данные

Exit Sub ' Завершение работы процедуры

scGSetDataOnSheet_Error: ' Что делать при ошибке

Call scG_ErrorLog(Err, "Global_Scripts", "scGSetDataOnSheet") ' Вызов обработчика ошибок

End Sub
' - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + -
Public Sub scG_ClearSheet(ByVal tSheet As Worksheet, ByVal mRow As Long)

On Error GoTo scG_ClearSheet_Error ' При ошибке переход по метке

lRow& = IIf(tSheet.UsedRange.Rows.Count > mRow, tSheet.UsedRange.Rows.Count, mRow + 1)

tSheet.Rows(mRow & ":" & lRow).Delete Shift:=xlUp

Exit Sub ' Завершение работы процедуры

scG_ClearSheet_Error: ' Что делать при ошибке

Call scG_ErrorLog(Err, "Global_Scripts", "scG_ClearSheet") ' Вызов обработчика ошибок

End Sub
Public Sub scG_OffFilterAll()

On Error GoTo scG_OffFilterAll_Error ' При ошибке переход по метке

ActiveSheet.ShowAllData

Exit Sub ' Завершение работы процедуры

scG_OffFilterAll_Error: ' Что делать при ошибке

Call scG_ErrorLog(Err, "Global_Scripts", "scG_OffFilterAll") ' Вызов обработчика ошибок

End Sub

Public Sub scG_ReturnFilters(ByRef temp() As String)

On Error GoTo scG_ReturnFilters_Error ' При ошибке переход по метке

For i = LBound(temp) To UBound(temp)

    If temp(i) <> "" Then
        If InStr(temp(i), ",") > 0 Then
            temp1 = Split(temp(i), ",")
            ActiveSheet.UsedRange.AutoFilter Field:=i, Criteria1:=temp1, Operator:=xlFilterValues
        Else
            ActiveSheet.UsedRange.AutoFilter Field:=i, Criteria1:=temp(i)
        End If
    End If
Next i

Exit Sub ' Завершение работы процедуры

scG_ReturnFilters_Error: ' Что делать при ошибке

Call scG_ErrorLog(Err, "Global_Scripts", "scG_ReturnFilters") ' Вызов обработчика ошибок

End Sub
